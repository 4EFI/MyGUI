#include <SFML/Graphics.hpp>
#include <stdio.h>
#include <string.h>
#include <windows.h>

const float MinScale = 0.15;

//-----------------------------------------------------------------------------

void SetCentrePosition(sf::Vector2f *centrePos, float v_move);

void SetScale(float *scale, float v_scaling, float dt);

sf::Vector2f GetCursorPosition(sf::RenderWindow &window);
void         ShowMenuPanel    (sf::RenderWindow &window);

//-----------------------------------------------------------------------------

class RectangleSelection
{
private:
    sf::RectangleShape rectangle;
    sf::Vector2f       startPosition;

    const int countCircles = 8;
    sf::CircleShape circles[8];

    void MoveCircleCenter(sf::Vector2f position, sf::CircleShape *circle);

    sf::Vector2f GetCircleCentre(sf::CircleShape *circle);
    bool         IsInsideCircle (sf::CircleShape *circle, sf::Vector2f position);

    void ShowEditTools(sf::RenderWindow &window, float scale = 1);

public:
    float radiusEditCircle   = 4;
    float radiusButtonCircle = 15;

    bool showEditTools = false;

    void Show         (sf::RenderWindow &window, float scale = 1, sf::Vector2f centrePos = {0, 0});

    bool SetTextureBoundaries(sf::RenderWindow &window, float scale = 1, sf::Vector2f centrePos = {0, 0});
    void Edit                (sf::RenderWindow &window, float scale = 1, sf::Vector2f centrePos = {0, 0});

    //bool IsInside

};

//-----------------------------------------------------------------------------
//{     RectangleSelection realization
//-----------------------------------------------------------------------------

void RectangleSelection::MoveCircleCenter(sf::Vector2f position, sf::CircleShape *circle)
{
    circle->setPosition(position.x - radiusEditCircle, position.y - radiusEditCircle);
}

//-----------------------------------------------------------------------------

sf::Vector2f RectangleSelection::GetCircleCentre(sf::CircleShape *circle)
{
    sf::Vector2f position = circle->getPosition();
    position.x += radiusEditCircle;
    position.y += radiusEditCircle;

    return position;
}

//-----------------------------------------------------------------------------

bool RectangleSelection::IsInsideCircle(sf::CircleShape *circle, sf::Vector2f position)
{
    sf::Vector2f circleCentre = GetCircleCentre(circle);

    if((position.x - circleCentre.x)*(position.x - circleCentre.x) +
       (position.y - circleCentre.y)*(position.y - circleCentre.y) <= radiusButtonCircle * radiusButtonCircle)
    {
        return true;
    }
    else
    {
        return false;
    }
}

//-----------------------------------------------------------------------------

void RectangleSelection::Show(sf::RenderWindow &window, float scale, sf::Vector2f centrePos)
{
    rectangle.setScale   (scale, scale);
    rectangle.setPosition(startPosition * scale + centrePos);

    window.draw(rectangle);

    if(showEditTools)
    {
        ShowEditTools(window, scale);
    }
}

//-----------------------------------------------------------------------------

void RectangleSelection::ShowEditTools(sf::RenderWindow &window, float scale)
{
    sf::Vector2f position = rectangle.getPosition();
    sf::Vector2f size     = rectangle.getSize();

    size *= scale;

    for(int i = 0; i < countCircles; i++)
    {
        circles[i].setRadius(radiusEditCircle);
        circles[i].setFillColor(sf::Color(0, 0, 0));
    }

    //Angular circles (L_UP & R_DOWN)
    MoveCircleCenter({ position.x,          position.y },          &circles[0]);
    MoveCircleCenter({ position.x + size.x, position.y + size.y }, &circles[2]);
    //Angular circles (R_UP & L_DOWN)
    MoveCircleCenter({ position.x + size.x, position.y },          &circles[1]);
    MoveCircleCenter({ position.x,          position.y + size.y }, &circles[3]);

    //Middle circles (Left & Right)
    MoveCircleCenter({ position.x,              position.y + size.y / 2 }, &circles[4]);
    MoveCircleCenter({ position.x + size.x,     position.y + size.y / 2 }, &circles[5]);
    //Middle circles (Up & Down)
    MoveCircleCenter({ position.x + size.x / 2, position.y },              &circles[6]);
    MoveCircleCenter({ position.x + size.x / 2, position.y + size.y },     &circles[7]);

    for(int i = 0; i < countCircles; i++)
    {
        circles[i].setRadius(radiusEditCircle);

        window.draw(circles[i]);
    }
}

//-----------------------------------------------------------------------------

bool RectangleSelection::SetTextureBoundaries(sf::RenderWindow &window, float scale, sf::Vector2f centrePos)
{
    bool isSetBoundaries = false;

    static bool leftButtonPressed = false;

    static sf::Vector2f pNow;

    if(GetAsyncKeyState(VK_LBUTTON))
    {
        if(!leftButtonPressed)
        {
            startPosition  = GetCursorPosition(window) - centrePos;
            startPosition /= scale;

            leftButtonPressed = true;
        }

        pNow  = GetCursorPosition(window) - centrePos;
        pNow /= scale;
    }
    else if (!GetAsyncKeyState(VK_LBUTTON) && leftButtonPressed == true)
    {
        leftButtonPressed = false;
        isSetBoundaries   = true;
    }

    rectangle.setSize(pNow - startPosition);

    rectangle.setFillColor(sf::Color(15, 180, 140));

    return isSetBoundaries;
}

//-----------------------------------------------------------------------------

void RectangleSelection::Edit(sf::RenderWindow &window, float scale, sf::Vector2f centrePos)
{
    sf::Vector2f cursorPosition;
    cursorPosition = GetCursorPosition(window);

    static sf::Vector2f sizeRec;

    static bool leftButtonPressed = false;

    static int  numEditCircle     = -1;
    static int  numOppositeCircle = -1;

    if(!GetAsyncKeyState(VK_LBUTTON))
    {
        leftButtonPressed = false;
        numEditCircle     = -1;
        numOppositeCircle = -1;

        return;
    }

    if(GetAsyncKeyState(VK_LBUTTON))
    {
        if(!leftButtonPressed)
        {
            leftButtonPressed = true;

            for(int i = 0; i < countCircles; i++)
            {
                if(IsInsideCircle(&circles[i], cursorPosition))
                {
                    numEditCircle = i;
                    break;
                }
            }

            if(numEditCircle == -1) return;

            if     (numEditCircle >= 0 && numEditCircle <= 3)
            {
                numOppositeCircle = (numEditCircle + 2) % 4;
            }
            else if(numEditCircle == 4 || numEditCircle == 6)
            {
                numOppositeCircle = 2;
            }
            else if(numEditCircle == 5 || numEditCircle == 7)
            {
                numOppositeCircle = 0;
            }

            startPosition = GetCircleCentre(&circles[numOppositeCircle]);
            startPosition = (startPosition - centrePos) / scale;

            sizeRec = rectangle.getSize();
        }
    }

    cursorPosition = (cursorPosition - centrePos) / scale;

    if(leftButtonPressed)
    {
        if     (numEditCircle >= 0 && numEditCircle <= 3)
        {
            rectangle.setSize(cursorPosition - startPosition);
        }
        else if(numEditCircle >= 4 && numEditCircle <= 5)
        {
            int k = (numEditCircle == 4) ? -1 : 1;

            rectangle.setSize({ cursorPosition.x - startPosition.x, k * sizeRec.y });
        }
        else if(numEditCircle >= 6 && numEditCircle <= 7)
        {
            int k = (numEditCircle == 6) ? -1 : 1;

            rectangle.setSize({ k * sizeRec.x, cursorPosition.y - startPosition.y });
        }
    }
}

//-----------------------------------------------------------------------------
//}  End of Block
//-----------------------------------------------------------------------------

class Button
{
private:
    sf::Sprite buttonSprite;

public:
    sf::Texture buttonTexture;

    Button()
    {
        buttonTexture.loadFromFile("Textures\\White.png");
        buttonSprite.setTexture(buttonTexture);

        buttonSprite.setTextureRect({0, 0, 100, 40});
    }

    void Show(sf::RenderWindow &window);
    void Click();
};

//-----------------------------------------------------------------------------
//{     Button realization
//-----------------------------------------------------------------------------

void Button::Show(sf::RenderWindow &window)
{
    window.draw(buttonSprite);
}

//-----------------------------------------------------------------------------
//}     End of block
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------

int main()
{
    char pathToTexture[100] = "ѕтичка кадры\\bird0.png";

    sf::Texture texture;
    texture.loadFromFile(pathToTexture);

    sf::Sprite spriteImg(texture);

    sf::RenderWindow window(sf::VideoMode(1000, 700), "Texture Manager");

    float scale = 1;
    sf::Vector2f centrePos = {0, 0};

    float v_moveCentre = 0.5;
    float v_scaling    = 0.001;

    sf::Clock clock;

    RectangleSelection rectangle;
    bool isSetBoundaries = false;

    sf::Texture backGroundTexture;
    backGroundTexture.loadFromFile("Textures\\ClearBackGround.jpg");

    sf::Sprite backGroundSprite(backGroundTexture);
    backGroundSprite.setScale(0.65, 0.65);

    Button button;

    while(true)
    {
        float dt = clock.getElapsedTime().asMicroseconds();
		dt /= 1000;
		clock.restart();

        sf::Event event;
        while (window.pollEvent(event))
        {
            if (event.type == sf::Event::Closed) window.close();
        }

        SetCentrePosition(&centrePos, v_moveCentre);
        SetScale         (&scale,     v_scaling, dt);

        window.clear({255, 255, 255});

        window.draw(backGroundSprite);

        if(!isSetBoundaries)
        {
            isSetBoundaries = rectangle.SetTextureBoundaries(window, scale, centrePos);

            rectangle.showEditTools = false;
        }
        else
        {
            rectangle.showEditTools = true;
            rectangle.Edit(window, scale, centrePos);
        }

        rectangle.Show(window, scale, centrePos);

        spriteImg.setPosition(centrePos);
        spriteImg.setScale   (scale, scale);

        window.draw(spriteImg);

        ShowMenuPanel(window);
        button.Show(window);

        window.display();
    }
}

//-----------------------------------------------------------------------------

void SetCentrePosition(sf::Vector2f *centrePos, float v_move)
{
    static bool rightButtonPressed = false;

    static POINT pStart;
    static POINT pNow;

    if(GetAsyncKeyState(VK_RBUTTON))
    {
        if(!rightButtonPressed)
        {
            GetCursorPos(&pStart);

            rightButtonPressed = true;
        }

        GetCursorPos(&pNow);

        if(pStart.x - pNow.x != 0 || pStart.y - pNow.y != 0)
        {
            centrePos->x -= (pStart.x - pNow.x) * v_move;
            centrePos->y -= (pStart.y - pNow.y) * v_move;

            GetCursorPos(&pStart);
        }
    }
    else
    {
        rightButtonPressed = false;
    }
}

//-----------------------------------------------------------------------------

void SetScale(float *scale, float v_scaling, float dt)
{
    if     (GetAsyncKeyState(VK_UP))
    {
        (*scale) += v_scaling * dt;
    }
    else if(GetAsyncKeyState(VK_DOWN))
    {
        (*scale) -= v_scaling * dt;
    }

    if(*scale < MinScale)
    {
        (*scale) = MinScale;
    }
}

//-----------------------------------------------------------------------------

sf::Vector2f GetCursorPosition(sf::RenderWindow &window)
{
    sf::Vector2f cursorPosition;

    cursorPosition = (sf::Vector2f)sf::Mouse::getPosition(window);
    cursorPosition = window.mapPixelToCoords((sf::Vector2i)cursorPosition);
}

//-----------------------------------------------------------------------------

void ShowMenuPanel(sf::RenderWindow &window)
{
    sf::RectangleShape panel;

    sf::Vector2u sizeWindow = window.getSize();

    panel.setSize({ sizeWindow.x, 80 });
    panel.setFillColor(sf::Color(220, 220, 220));

    window.draw(panel);
}

//-----------------------------------------------------------------------------
